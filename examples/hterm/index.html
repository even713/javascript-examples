<!DOCTYPE html>
<html>
<style>
html{
	height: 100%;
}
#terminal{
	border: 1px solid red;
}
</style>
  <body>
    <div id="terminal"
         style="position:relative; width:100%; height:900px"></div>
  </body>
  <script src="hterm_all.js"></script>
  <script>
  // If you are a cross-browser web app and want in-memory storage only.
  hterm.defaultStorage = new lib.Storage.Memory();

	// opt_profileName is the name of the terminal profile to load, or "default" if
	// not specified.  If you're using one of the persistent storage
	// implementations then this will scope all preferences read/writes to this
	// name.
	const t = new hterm.Terminal();

t.onTerminalReady = function() {
  // Create a new terminal IO object and give it the foreground.
  // (The default IO object just prints warning messages about unhandled
  // things to the the JS console.)
  const io = t.io.push();

  io.onVTKeystroke = (str) => {
  	console.log("onVTKeystroke", str);
  	t.io.print(str);
    // Do something useful with str here.
    // For example, Secure Shell forwards the string onto the NaCl plugin.
  };

  io.sendString = (str) => {
  	console.log("sendString", str);
    // Just like a keystroke, except str was generated by the terminal itself.
    // For example, when the user pastes a string.
    // Most likely you'll do the same thing as onVTKeystroke.
  };

  io.onTerminalResize = (columns, rows) => {
  	console.log("onTerminalResize", columns, rows);
    // React to size changes here.
    // Secure Shell pokes at NaCl, which eventually results in
    // some ioctls on the host.
  };

  // You can call io.push() to foreground a fresh io context, which can
  // be uses to give control of the terminal to something else.  When that
  // thing is complete, should call io.pop() to restore control to the
  // previous io object.
};

t.decorate(document.querySelector('#terminal'));

t.installKeyboard();	

t.io.print('Print a string without a newline');
t.io.println('Print a string and add CRLF');
  </script>
</html>