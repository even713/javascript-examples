<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>d3 bubble chart</title>
    <style>
        .node{
            fill: #ccc;
            stroke: #fff;
            stroke-width: 2px;
        }

        .container{
            display: -webkit-flex;
            display: flex;
        }

        .chart {
            -webkit-flex: 1;
            flex: 1;
            border: 1px solid grey;
            height: 500px;
        }
    </style>
</head>
<body>
    <button id="start" onclick="startChart()">Start</button>
    <button id="update" onclick="updateNodes()">Update</button>
    <button id="resize" onclick="resizeChart()">Resize</button>
    <div class="container">
        <div class="chart chart1"></div>
        <div class="chart chart2"></div>
        <div class="chart chart3"></div>
        <div class="chart chart4"></div>
        <div class="chart chart5"></div>
    </div>
</body>
<script src="/vendor/d3/d3.v35.js"></script>
<!--<script src="https://d3js.org/d3.v3.js"></script>-->
<script src="BubbleChartClass.js"></script>
<script>
     var width = 250,
     	 height = 250,
             chartInstance = [],
             data;
//
//     var canvas = d3.select("body").append("svg")
//     			.attr("width", width)
//     			.attr("height", height)
//     			.append("g")
//     			.attr("transform", "translate(50, 50)");

     d3.json("data.json", function(d){
         data = d;
//         chartInstance = new BubbleChart({
//             width: width,
//             height: height,
//             container: ".chart",
//             gravity: 0.45,
//             friction: 0.3
//         }, data)
     });

     function resizeChart(){
         width = 300;
         height = 300;
         chartInstance[0].resizeChart(width, height);
     }

     function startChart(){
         console.time("createChart");
         for(let i = 0; i < 1; i ++) {
             chartInstance.push(new BubbleChart({
                 width: width,
                 height: height,
                 container: ".chart" + (i + 1),
                 gravity: 0.45,
                 friction: 0.3
             }, data))
         }
     }

     function updateNodes(){
         d3.json("data2.json", function(data){
             chartInstance.refresh(data);
         });
     }

     class BubbleChart2 {
         getLevels(){
             return {
                 "Critical": {color: "rgb(219, 27, 27)", y: this.height / 6},
                 "Major": {color: "rgb(255, 99, 33)", y: this.height / 3},
                 "Minor": {color: "rgb(255, 208, 51)", y: this.height / 2},
                 "Normal": {color: "rgb(123, 220, 42)", y: 2 * this.height / 3},
                 "NoData": {color: "#ccc", y: 5 * this.height / 6}
             }
         }

         constructor(option, data){
             this.GRAVITY = option.gravity || 0.5;
             this.COLLIDE = option.collide || 0.1;
             this.FRICTION = option.friction || 0.3;

             this.width = option.width || 600;
             this.height = option.height || 800;
             this.container = option.container;

             this.sourceData = data;

             this._initialize();
         }

         _initialize(){

                     //.on("tick", this._tick.bind(this));

             this._create();
         }

         _create(){
             this.svg = d3.select(this.container)
                     .append("svg")
                     .attr("width", this.width)
                     .attr("height", this.height);

             this.updateChart(this.sourceData);
         }

         updateChart(data){
             //this._force.stop();
             this.sourceData = data;
             this.nodesData = this._createNodes(data);

             var force = d3.layout.force()
                     .size([this.width, this.height])
                     .charge(this._charge)
                     .gravity(this.GRAVITY)
                     .friction(this.FRICTION);

             force.nodes(this.nodesData);
             //console.log("before", JSON.parse(JSON.stringify(this.nodesData)));

             force.start();
             let n = 30;
             console.time("force");
             for (var i = n * n; i > 0; --i) force.tick();
             force.stop();
             console.timeEnd("force");
             //console.log("after", JSON.parse(JSON.stringify(this.nodesData)));


             this._bubbles = this.svg.selectAll(".bubble")
                     .data(this.nodesData);
             this._bubbles.exit()
                     .remove();
             this._bubbles.enter()
                     .append("circle");

             this._bubbles.attr("class", "bubble")
                     .attr("fill", function (d) {
                         return this.getLevels()[d.level].color;
                     }.bind(this))
                     .attr("r", function (d) {
                         return d.radius;
                     })
                     .attr("cx", function(d){return d.x;})
                     .attr("cy", function(d){return d.y;});
         }

         _createNodes(data){

            this._setRadiusScale(data);

            let nodes = data.map(function(d){
                let healthLevel = this._getHealthLevel(d.healthScore);
                //d.value = 300;
                return {
                    name: d.name,
                    value: d.value,
                    radius: this._getRadiusScale()(d.value), // the circle size depends on
                    level: healthLevel,
                    x: Math.random() * width,
                    y: this.getLevels()[healthLevel].y
                }
            }.bind(this));

            nodes.sort(function (a, b) { return b.value - a.value; });

            return nodes;
         }

         _tick(e) {
             //this._bubbles
                 //.each(this._gravity(e.alpha * this.GRAVITY))
                 //.each(this._collide(this.COLLIDE, this.nodesData))
                 //.attr('cx', function (d) {
                 //        return d.x; })
                 //.attr('cy', function (d) { return d.y; });
         }

         _charge(d){
             return -Math.pow(d.radius, 2.0) * 2.5;
         }

         _getRadiusScale(){
             if(!this._radiusScale)
             {
                 this._radiusScale = d3.scale.pow()
                         .exponent(0.5)
                         //.range([0, Math.min(this.width, this.height) / 7]);
             }

             return this._radiusScale;
         }

         _setRadiusScale(data){
             let maxV = d3.max(data, function(d){return +d.value || 0;}),
                     sumV = d3.sum(data, function(d){return +d.value || 0;}),
                     domain = [0, maxV],
                     maxRange = ((Math.min(this.width, this.height)/ 2) * Math.pow(maxV/sumV, 0.5)) + 1,
                    // avg = Math.,
                     ranges = [1, maxRange * 0.65];
             console.log("ranges", ranges);
             console.log("domain", domain);
             this._getRadiusScale()
                     .range(ranges)
                     .domain(domain);
         }

         _getHealthLevel(healthScore){
             let levels = d3.keys(this.getLevels());
             if(healthScore >= 0 && healthScore < 25) {
                 return levels[0];
             } else if(healthScore >= 25 && healthScore < 50) {
                 return levels[1];
             } else if(healthScore >= 50 && healthScore < 75) {
                 return levels[2];
             } else if(healthScore >= 75 && healthScore <= 100) {
                 return levels[3];
             } else {
                 return levels[4];
             }
         }

//         _gravity(k) {
//             return function(d) {
//                 if (typeof(d.tx) !== "undefined") {
//                     d.x = d.x + (d.tx - d.x) * k;
//                     d.y = d.y + (d.ty - d.y) * k;
//                 }
//             };
//         }
//
//         _collide(k, nodes) {
//             var q = d3.geom.quadtree(nodes),
//                    padding = 0;
//             return function (node) {
//                 if(node.name == "child1")
//                     console.log("watch d", "before _collide", node.x, JSON.parse(JSON.stringify(node)))
//                 var nr = node.r + padding,
//                         nx1 = node.x - nr,
//                         nx2 = node.x + nr,
//                         ny1 = node.y - nr,
//                         ny2 = node.y + nr;
//                 q.visit(function (quad, x1, y1, x2, y2) {
//                     if (quad.point && (quad.point !== node )) {
//                         var x = node.x - quad.point.x,
//                                 y = node.y - quad.point.y,
//                                 l = x * x + y * y,
//                                 r = nr + quad.point.r;
//
//                         if (l < r * r) {
//                             l = ((l = Math.sqrt(l)) - r) / l * k;
//                             node.x -= x *= l;
//                             node.y -= y *= l;
//                             quad.point.x += x;
//                             quad.point.y += y;
//                         }
//                     }
//                     return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
//                 });
//
//                 if(node.name == "child1")
//                     console.log("watch d", "after _collide", node.x, JSON.parse(JSON.stringify(node)))
//             };
//         }
     }

</script>